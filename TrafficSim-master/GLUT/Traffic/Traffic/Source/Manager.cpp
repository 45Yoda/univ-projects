#include "Manager.h"
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"



#include "Car.h"


using namespace std;


// Manager initializer.
Manager::Manager() {
	cout << "LezGo" << endl;
}

int Manager::init() {

	carNumber = 2;

	// Load files
	char* file = (char*)"Source/Files/mapTests3intersection.osm";

	parser.loadFile(file);

	nodes = parser.getNodes();

	waysMap = Parser::getMap();

	drawMap = Parser::getMapToDraw();


	junctsToDraw = Parser::getJuncsToDraw();


	setupCarLocationVecs();

	//vector<long long> intersections = parser.getIntersections();

	orderRoads();

	// REMOVE comment
	/*
	for (auto const& s : waysMap) {


		cout << "WHAT WAY? " << s.first << endl;


		for (auto const& wayd : s.second.choices) {

			cout << "NEW CHOICE " << endl;

			for (auto const& choic : wayd) {

				cout << "GIVE ME THE NODE ID" << endl;
				cout << choic->id << endl;
			}
		}

	}
	*/

	//cout << "THESE ARE THE INTERSECTIONS FOUND" << endl;
	//for (auto const& ref : intersections) {

	//	cout << ref << endl;
	//}


	// Get the possible MapEntrances and the MapExits
	// TODO CORRECT (remove this comment after debug)
	mapEntrances = parser.getEntrances();
	mapExits = parser.getExits();

	//Will be used to obtain a seed for the random number engine
	random_device rd;
	//Standard mersenne_twister_engine seeded with rd()
	mt19937 gen(rd());
	uniform_int_distribution<> distrib(0, mapEntrances.size() - 1);


	for (int car = 0; car < carNumber; car++) {
		//Use `distrib` to transform the random unsigned int generated by gen into an int in [0,mapEntrance.size()-1]
		int ind = distrib(gen);
		auto it = mapEntrances.begin();
		advance(it, ind);

		auto it2 = waysMap.find(*it);
		if (it2 != waysMap.end()) {


			Car* carObj = new Car(it2->second, car);
			carObj->mapExits = mapExits;
			//Car* carObj = new Car(it2->second.choices[0], car);
			cars.push_back(carObj);

		}

	}

	setUpWithMap();


	return 0;
}

int Manager::generateTex() {

	glGenTextures(1, &texture);
	glBindTexture(GL_TEXTURE_2D, texture);


	// Set the texture wrapping/filtering options (on currently bound texture object)
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

	//char* fileName = "Source/Textures/ping.png";

	// Load and generate the texture
	int width, height, nrChannels;
	unsigned char* data = stbi_load("Source/Textures/cat.png", &width, &height, &nrChannels, 3);

	if (stbi_failure_reason()) {
		cout << stbi_failure_reason();
	}
	else {
		cout << "Hello" << endl;
	}

	if (data) {
		cout << "SUCCESSFULL" << endl;
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
		glGenerateMipmap(GL_TEXTURE_2D);
	}
	else {
		cout << "Failed to load texture" << endl;
	}


	stbi_image_free(data);


	return 0;
}

void Manager::setUpWithMap() {

	Path* currPath = new Path();
	vector<Path*> alotOfPaths;

	intersections = parser.getAllIntersections();

	int found = 0;

	cout << "--------------------------------------------" << endl;

	cout << "DRAW MAP" << endl;

	for (auto const& ent1 : drawMap) {


		// Outer Vector
		for (auto const& outer : ent1.second.draw_choices) {

			//int i = 0;
			int found = 0;



			// Inner Vector
			cout << "INNER" << endl;
			for (auto const& inner : outer) {

				if (found == 0 && intersections->find(inner->id) != intersections->end()) {

					/*

					if (i == 0) {
						i = 1;
					}
					else {
						i = 2;
					}
					*/

					currPath->intersectionPoint = inner->id;
					found = 1;
				}


				cout << inner->id << endl;
				cout << inner->lon << "," << "0" << inner->lat << endl;

				currPath->pushInfo(inner->id, vec3(inner->lon, 0, inner->lat));

				/*
				if (found == 0) {
					i++;
				}
				*/

			}
			// Instead of storing this here directly do the perpendicular calculations and form a vector;
			currPath->generatePath();

			currPath->isIntersection = found;

			alotOfPaths.push_back(currPath);

			currPath = new Path();
		}

	}
	cout << "--------------------------------------------" << endl;

	//TooBad Better to be careful than to be fucked
	currPath = new Path();

	//TooBad ADDED THiS Tá mais ou menos
	for (auto const& junct : junctsToDraw) {

		for (auto const& inner : junct.fullWay) {

			currPath->pushInfo(inner->id, vec3(inner->lon, 0, inner->lat));
		}

		currPath->generatePath();
		alotOfPaths.push_back(currPath);

		currPath = new Path();
	}



	vec3(up);
	vector<vec3> pathFormation;
	vector<vec3> sidewalkFormation;

	cout << "-------------------------------------------" << endl;


	for (auto const& path : alotOfPaths) {

		//Compare the first and last ids of the nodes to know what road this is in an intersection
		// place an if to disregard if not an intersection
		// also try to know if it starts or ends in the intersection point
		// replace the 2 values with the intersection values still need to know if its the left first or the right first (I think its the right first)

		vector<long long> ids = path->getInfo();


		pair<vec3, vec3> connPoints;
		pair<vec3, vec3> endConnPoints;
		int intersectType = 0;
		int flag = 0;
		int flag2 = 0;

		if (path->isIntersection) {

			cout << "ROADS" << endl;
			for (int i = 0; i < (*intersections)[path->intersectionPoint].connectedRoads.size() && !flag; i++) {


				vector<Parser::Node*> currRoad = (*intersections)[path->intersectionPoint].connectedRoads[i];
				long long beginIntersect = currRoad[0]->id;
				long long endIntersect = currRoad[currRoad.size() - 1]->id;

				long long beginPath = ids[0];
				long long endPath = ids[ids.size() - 1];

				/*

				vec3 test1 = vec3(currRoad[0]->lon, 0, currRoad[0]->lat);
				vec3 test2 = vec3(currRoad[currRoad.size() - 1]->lon, 0, currRoad[currRoad.size() - 1]->lat);

				cout << "----------------------------------------" << endl;

				cout << "TESTING THINGS" << endl;
				cout << "ID1 " << beginIntersect << endl;
				cout << "TEST1" << endl;
				cout << test1.x << "," << test1.z << endl;
				cout << "ID2 " << endIntersect << endl;
				cout << "TEST2" << endl;
				cout << test2.x << "," << test2.z << endl;

				vector<vec3> ptsTest = path->getPoints();

				cout << "POINTS " << endl;
				for (int m = 0; m < ptsTest.size(); m++) {
					cout << ptsTest[m].x << "," << ptsTest[m].z << endl;
				}

				cout << "----------------------------------------" << endl;

				*/


				if (beginIntersect == beginPath && endIntersect == endPath) {
					// REMOVE comment

					cout << beginIntersect << "     " << endIntersect << endl;
					cout << beginPath << "     " << endPath << endl;
					cout << "HELLO" << endl;

					connPoints = (*intersections)[path->intersectionPoint].connectionPoints[i];
					intersectType = (*intersections)[path->intersectionPoint].intersectionTypes[i];


					// used to retrieve the other end's connection points
					long long otherEnd = 0;

					if (beginIntersect == path->intersectionPoint) {
						otherEnd = endIntersect;
					}
					else {
						otherEnd = beginIntersect;
					}

					if (otherEnd != 0) {

						if ((*intersections).find(otherEnd) != (*intersections).end()) {

							for (int j = 0; j < (*intersections)[otherEnd].connectedRoads.size() && !flag2; j++) {


								vector<Parser::Node*> roadInside = (*intersections)[otherEnd].connectedRoads[j];
								long long beginIntersectInside = roadInside[0]->id;
								long long endIntersectInside = roadInside[roadInside.size() - 1]->id;

								// this is the other end of the road so the "beginning" of the intersection
								// has to be the same as the end and the "ending" of the intersection
								//has to be the same as the beginning
								cout << "TESTING THINGS" << endl;
								cout << "ID1 " << beginIntersect << endl;
								cout << "TEST1" << endl;
								cout << beginIntersectInside << endl;
								cout << "ID2 " << endIntersect << endl;
								cout << "TEST2" << endl;
								cout << endIntersectInside << endl;




								if (beginIntersectInside == beginIntersect && endIntersectInside == endIntersect) {

									endConnPoints = (*intersections)[endIntersect].connectionPoints[j];

									flag2 = 1;
								}

							}
						}

					}



					cout << "INTERSECT TYPE" << endl;
					cout << intersectType << endl;

					cout << "CONN POINTS" << endl;
					cout << "INTERSECTION POINT " << path->intersectionPoint << endl;

					cout << "LEFT " << connPoints.first.x << "," << connPoints.first.y << "," << connPoints.first.z << endl;
					cout << "RIGHT " << connPoints.second.x << "," << connPoints.second.y << "," << connPoints.second.z << endl;

					cout << "....................." << endl;
					cout << "END CONN POITNS" << endl;
					cout << "INTERSECTION POINT" << endIntersect << endl;

					cout << "LEFT2" << endConnPoints.first.x << "," << endConnPoints.first.y << "," << endConnPoints.first.z << endl;
					cout << "RIGHT2" << endConnPoints.second.x << "," << endConnPoints.second.y << "," << endConnPoints.second.z << endl;

					cout << "STOP" << endl;
					flag = 1;
				}

			}

		}



		// Flag used to replace the first points or last points of a intersection depending on the intersectionPoint position



		for (int a = 0; a < path->getSegmentNumber(); a++) {


			int replace = 1;
			int replace2 = 9;

			if (intersectType == 1 && a == 0 && flagTurnOffIntersections) {
				pathFormation.push_back(connPoints.first);
				pathFormation.push_back(connPoints.second);

				//cout << "PATHFORMATION" << endl;
				/*

					vec3 sidewa = vec3(0);
					vec3 sidewa2 = vec3(0);

					sidewa.x *= connPoints.first.x * (sidewalkHalf / roadHalf);
					sidewa.y *= 0;
					sidewa.z *= connPoints.first.z * (sidewalkHalf / roadHalf);

					sidewa2.x *= connPoints.second.x * (sidewalkHalf / roadHalf);
					sidewa2.y *= 0;
					sidewa2.z *= connPoints.second.z * (sidewalkHalf / roadHalf);

					sidewalkFormation.push_back(sidewa);
					sidewalkFormation.push_back(sidewa2);
				*/
			}
			else {
				if (flag2 == 1 && a == 0) {

					cout << "I AM HERE " << endl;
					cout << path->isIntersection << endl;
					pathFormation.push_back(endConnPoints.first);
					pathFormation.push_back(endConnPoints.second);
				}
			}

			int l = 0;

			// TODO problem with points can be over here becaus getPoint(... , float) and I pass it a double
			for (double dt = 0; dt <= 1; dt += 0.1) {

				cout << "l" << ": " << l << endl;
				l++;


				if (intersectType == 1 && replace != 0 && a == 0 && flagTurnOffIntersections) {
					replace -= 1;
					continue;
				}
				else {
					if (flag2 == 1 && replace != 0) {
						replace -= 1;
						continue;
					}
				}


				if (intersectType == 2 && a == path->getSegmentNumber() - 1 && flagTurnOffIntersections) {

					if (replace2 != 0) {
						replace2 -= 1;
					}
					else {
						break;
					}
				}
				else {
					if (a == path->getSegmentNumber() - 1 && flag2 == 1) {
						cout << "HERE LOL" << endl;


						if (replace2 != 0) {
							replace2 -= 1;
						}
						else {
							break;
						}
					}
				}

				vec3 newPoint = path->getPoint(a, dt);


				vec3 newDeriv = path->getDerivative(a, dt);

				//TODO possibly normalize deriv before doing the cross product

				vec3 res = cross(newDeriv, up);

				res = normalize(res);

				res.x *= roadHalf;
				res.y = 0;
				res.z *= roadHalf;

				vec3 sid = cross(newDeriv, up);
				sid = normalize(sid);

				sid.x *= sidewalkHalf;
				sid.y = 0;
				sid.z *= sidewalkHalf;


				vec3 perpSet1 = newPoint + res;
				vec3 perpSet2 = newPoint - res;

				vec3 sideSet1 = newPoint + sid;
				vec3 sideSet2 = newPoint - sid;


				pathFormation.push_back(perpSet1);
				pathFormation.push_back(perpSet2);

				sidewalkFormation.push_back(sideSet1);
				sidewalkFormation.push_back(sideSet2);
				/*
				cout << ".................................." << endl;
				cout << "PATH FORMATION 1" << endl;
				cout << perpSet1.x << "," << perpSet1.z << endl;
				cout << "PATH FORMATION 2" << endl;
				cout << perpSet2.x << "," << perpSet2.z << endl;
				*/

			}
			cout << ".................................." << endl;


			if (intersectType == 2 && a == path->getSegmentNumber() - 1 && flagTurnOffIntersections) {
				pathFormation.push_back(connPoints.first);
				pathFormation.push_back(connPoints.second);

				/*
					vec3 sidewa = vec3(0);
					vec3 sidewa2 = vec3(0);

					sidewa.x *= connPoints.first.x * (sidewalkHalf / roadHalf);
					sidewa.y *= 0;
					sidewa.z *= connPoints.first.z * (sidewalkHalf / roadHalf);

					sidewa2.x *= connPoints.second.x * (sidewalkHalf / roadHalf);
					sidewa2.y *= 0;
					sidewa2.z *= connPoints.second.z * (sidewalkHalf / roadHalf);

					sidewalkFormation.push_back(sidewa);
					sidewalkFormation.push_back(sidewa2);
				*/
			}
			else {
				if (a == path->getSegmentNumber() - 1 && flag2 == 1) {


					cout << "I AM HERE 2" << endl;
					cout << path->isIntersection << endl;
					pathFormation.push_back(endConnPoints.first);
					pathFormation.push_back(endConnPoints.second);
				}
			}

		}


		// Remove comment

		cout << "PATH FORMATION" << endl;
		for (int c = 0; c < pathFormation.size(); c++) {
			cout << pathFormation[c].x << "," << pathFormation[c].z << endl;

		}


		// Used to separate the correct vectors
		pathSets.push_back(pathFormation);
		pathFormation.clear();


		// Used to separate the correct vectors for the sidewalk
		sidewalkSets.push_back(sidewalkFormation);
		sidewalkFormation.clear();

	}


	map<long long, Parser::Intersection>::iterator intersection;

	vector<vec3> drawInters;

	for (intersection = intersections->begin(); intersection != intersections->end(); intersection++) {

		// THIS IS THE PLACE WHERE IT FUCKS UP
		// In roads with only 3 connected streets we still have 4 connection points


		if (intersection->second.connectedRoads.size() < 4) {

			for (int i = 0; i < intersection->second.connectedRoads.size(); i++) {

				vector<vec3>::iterator it;

				if (intersection->second.connectedRoads[i][0]->id != intersection->second.intersectionPoint->id) {

					if (i == 0) {

						drawInters.push_back(intersection->second.connectionPoints[i].first);
						drawInters.push_back(intersection->second.connectionPoints[i].second);

					}
					else {


						it = find(drawInters.begin(), drawInters.end(), intersection->second.connectionPoints[i].first);

						if (it == drawInters.end()) {
							drawInters.push_back(intersection->second.connectionPoints[i].first);
						}

						it = find(drawInters.begin(), drawInters.end(), intersection->second.connectionPoints[i].second);

						if (it == drawInters.end()) {
							drawInters.push_back(intersection->second.connectionPoints[i].second);
						}

					}

				}
				else {

					if (i == 0) {
						drawInters.push_back(intersection->second.connectionPoints[i].second);
						drawInters.push_back(intersection->second.connectionPoints[i].first);
					}
					else {

						it = find(drawInters.begin(), drawInters.end(), intersection->second.connectionPoints[i].second);

						if (it == drawInters.end()) {
							drawInters.push_back(intersection->second.connectionPoints[i].second);
						}

						it = find(drawInters.begin(), drawInters.end(), intersection->second.connectionPoints[i].first);

						if (it == drawInters.end()) {
							drawInters.push_back(intersection->second.connectionPoints[i].first);
						}

					}

				}

			}


		}
		else {


			for (int i = 0; i < intersection->second.connectionPoints.size(); i++) {




				if (intersection->second.connectedRoads[i][0]->id == intersection->second.intersectionPoint->id) {
					drawInters.push_back(intersection->second.connectionPoints[i].second);


				}
				else {
					drawInters.push_back(intersection->second.connectionPoints[i].first);
				}
			}
		}

		intersectionsToDraw.push_back(drawInters);
		drawInters.clear();

		// NEED TO DRAW INTERSECTIONS AND JUNCTIONS NEXT DO NOT FORGET THEN GO TO THE TEXTURES PART.x

	}

	for (int i = 0; i < intersectionsToDraw.size(); i++) {
		cout << "POINTS" << endl;
		for (int s = 0; s < intersectionsToDraw[i].size(); s++) {

			cout << intersectionsToDraw[i][s].x << "," << intersectionsToDraw[i][s].y << "," << intersectionsToDraw[i][s].z << endl;
		}
	}

	// Remove comment
	/*
	cout << "DEBUGGING" << endl;
	for (int s = 0; s < pathSets.size(); s++) {
		cout << "PATHSET NR-> " << s << endl;

		cout << "SIZE-> " << pathSets[s].size() << endl;
		for (int deb = 0; deb < pathSets[s].size(); deb++) {

			cout << pathSets[s][deb].x << "," << pathSets[s][deb].y << "," << pathSets[s][deb].z << endl;

		}
	}
	*/

}


vector<vector<vec3>> Manager::getPathSets() {
	return pathSets;
}

void Manager::drawPaths() {



	
	for (int i = 0; i < intersectionsToDraw.size(); i++) {

		glPushMatrix();
		
		//glColor3f(0, 1.0, 0.0);
		glEnable(GL_TEXTURE_2D);
		glBindTexture(GL_TEXTURE_2D, texture);
		/*
		glBegin(GL_TRIANGLE_FAN);

		for (int s = 0; s < intersectionsToDraw[i].size(); s++) {
			glVertex3f(intersectionsToDraw[i][s].x, intersectionsToDraw[i][s].y, intersectionsToDraw[i][s].z);
		}
		*/
		glBegin(GL_QUADS);
		glNormal3f(0, 1, 0);
		
		glTexCoord2f(0.0, 0.0);
			glVertex3f(intersectionsToDraw[0][1].x, intersectionsToDraw[0][1].y, intersectionsToDraw[0][1].z);
		glTexCoord2f(1.0, 0.0);
			glVertex3f(intersectionsToDraw[0][2].x, intersectionsToDraw[0][2].y, intersectionsToDraw[0][2].z);
		glTexCoord2f(1.0, 1.0);
			glVertex3f(intersectionsToDraw[0][3].x, intersectionsToDraw[0][3].y, intersectionsToDraw[0][3].z);
		glTexCoord2f(0.0, 1.0);
			glVertex3f(intersectionsToDraw[0][0].x, intersectionsToDraw[0][0].y, intersectionsToDraw[0][0].z);
		glEnd();
		glDisable(GL_TEXTURE_2D);

		glBegin(GL_LINES);
		glColor3f(1, 0, 0);
		glVertex3f(intersectionsToDraw[0][0].x, intersectionsToDraw[0][0].y, intersectionsToDraw[0][0].z);
		glVertex3f(intersectionsToDraw[0][0].x, 100, intersectionsToDraw[0][0].z);
		glEnd();

		glBegin(GL_LINES);
		glColor3f(0, 1, 0);
		glVertex3f(intersectionsToDraw[0][1].x, intersectionsToDraw[0][1].y, intersectionsToDraw[0][1].z);
		glVertex3f(intersectionsToDraw[0][1].x, 100, intersectionsToDraw[0][1].z);
		glEnd();

		glBegin(GL_LINES);
		glColor3f(0, 0, 1);
		glVertex3f(intersectionsToDraw[0][2].x, intersectionsToDraw[0][2].y, intersectionsToDraw[0][2].z);
		glVertex3f(intersectionsToDraw[0][2].x, 100, intersectionsToDraw[0][2].z);
		glEnd();
		
		glBegin(GL_LINES);
		glColor3f(1, 0, 1);
		glVertex3f(intersectionsToDraw[0][3].x, intersectionsToDraw[0][3].y, intersectionsToDraw[0][3].z);
		glVertex3f(intersectionsToDraw[0][3].x, 100, intersectionsToDraw[0][3].z);
		glEnd();

		
		
		
		
		
		glPopMatrix();

	}






	for (int y = 0; y < pathSets.size(); y++) {

		/*
		glPushMatrix();
		glColor3f(0.5, 0.5, 0.5);
		glBegin(GL_TRIANGLE_STRIP);
		for (int d = 0; d < pathSets[y].size(); d++) {
			glVertex3f(pathSets[y][d].x, pathSets[y][d].y, pathSets[y][d].z);
		}
		glEnd();
		glPopMatrix();
		*/


		for (int d = 0; d < pathSets[y].size() - 3; d++) {
			//glActiveTexture(GL_TEXTURE0);
			//glBindTexture(GL_TEXTURE_2D, texture);
			glPushMatrix();

			glColor3f(0.5, 0.5, 0.5);

			glBegin(GL_TRIANGLES);
			glVertex3f(pathSets[y][d].x, pathSets[y][d].y, pathSets[y][d].z);
			glVertex3f(pathSets[y][d + 1].x, pathSets[y][d + 1].y, pathSets[y][d + 1].z);
			glVertex3f(pathSets[y][d + 3].x, pathSets[y][d + 3].y, pathSets[y][d + 3].z);
			glEnd();

			glBegin(GL_TRIANGLES);
			glVertex3f(pathSets[y][d + 2].x, pathSets[y][d + 2].y, pathSets[y][d + 2].z);
			glVertex3f(pathSets[y][d].x, pathSets[y][d].y, pathSets[y][d].z);
			glVertex3f(pathSets[y][d + 3].x, pathSets[y][d + 3].y, pathSets[y][d + 3].z);
			glEnd();

			glPopMatrix();
		}
	}






	/*
	for (int y = 0; y < sidewalkSets.size(); y++) {

		for (int d = 0; d < sidewalkSets[y].size() - 3; d++) {
			glPushMatrix();

			glColor3f(0.4, 0.4, 0.4);

			glBegin(GL_TRIANGLES);
			glVertex3f(pathSets[y][d+1].x, pathSets[y][d+1].y, pathSets[y][d+1].z);
			glVertex3f(sidewalkSets[y][d + 1].x, sidewalkSets[y][d + 1].y, sidewalkSets[y][d + 1].z);
			glVertex3f(sidewalkSets[y][d + 3].x, sidewalkSets[y][d + 3].y, sidewalkSets[y][d + 3].z);
			glEnd();

			glBegin(GL_TRIANGLES);
			glVertex3f(pathSets[y][d + 3].x, pathSets[y][d + 3].y, pathSets[y][d + 3].z);
			glVertex3f(pathSets[y][d + 1].x, pathSets[y][d + 1].y, pathSets[y][d + 1].z);
			glVertex3f(sidewalkSets[y][d + 3].x, sidewalkSets[y][d + 3].y, sidewalkSets[y][d + 3].z);
			glEnd();

			glPopMatrix();

			glPushMatrix();

			glColor3f(0.4, 0.4 , 0.4);

			glBegin(GL_TRIANGLES);
			glVertex3f(sidewalkSets[y][d].x, sidewalkSets[y][d].y, sidewalkSets[y][d].z);
			glVertex3f(pathSets[y][d].x, pathSets[y][d].y, pathSets[y][d].z);
			glVertex3f(pathSets[y][d + 2].x, pathSets[y][d + 2].y, pathSets[y][d + 2].z);
			glEnd();

			glBegin(GL_TRIANGLES);
			glVertex3f(sidewalkSets[y][d +2].x, sidewalkSets[y][d +2].y, sidewalkSets[y][d+2].z);
			glVertex3f(sidewalkSets[y][d].x, sidewalkSets[y][d].y, sidewalkSets[y][d].z);
			glVertex3f(pathSets[y][d + 2].x, pathSets[y][d + 2].y, pathSets[y][d + 2].z);
			glEnd();



			glPopMatrix();

		}
	}
	*/


	dTesting();
}


vector<Car*> Manager::getCars() {
	return cars;
}
int Manager::getCarNumber() {
	return carNumber;
}

void Manager::drawCars() {

	for (int c = 0; c < cars.size(); c++) {

		if (cars[c]->exited) {
			//resetCar(cars[c]);
			//	This could give me id problems.
			//  TooBad I don't actually care all that much
			createNew(c);
			cars.erase(cars.begin() + c);
		}
		else {
			glPushMatrix();
			cars[c]->update();
			cars[c]->draw();
			glPopMatrix();
		}

	}
}

void Manager::dTesting() {


	/*

	for (int i = 0; i < nodes.size(); i++) {

		if (nodes[i].id == 896603215 || nodes[i].id == 7700562779 || nodes[i].id == 896610135 || nodes[i].id == 896610144 || nodes[i].id == 896610137 || nodes[i].id == 896610146) {

			glPushMatrix();
			glBegin(GL_LINES);
			glVertex3f(nodes[i].lon, 0, nodes[i].lat);
			glVertex3f(nodes[i].lon, 100, nodes[i].lat);
			glEnd();
			glPopMatrix();
		}

	}

	*/


	/*
	for (int s = 0; s < pathsTest.size(); s++) {

		glPushMatrix();
		for (int l = 0; l < pathsTest[s].size() - 2; l++) {



			glBegin(GL_LINES);
			glVertex3f(pathsTest[s][l].x, pathsTest[s][l].y, pathsTest[s][l].z);
			glVertex3f(pathsTest[s][l+2].x, pathsTest[s][l+2].y, pathsTest[s][l+2].z);
			glEnd();

		}
		glPopMatrix();
	}
	*/





	glPushMatrix();



	/*
	glBegin(GL_LINES);
	glColor3f(0, 0, 1);
	glVertex3f(-663.907, 0, 583.473);
	glVertex3f(-663.907, 100, 583.473);
	glEnd();

	glBegin(GL_LINES);
	glColor3f(1, 0, 1);
	glVertex3f(-666.135, 0, 575.558);
	glVertex3f(-666.135, 100, 575.558);
	glEnd();

	glBegin(GL_LINES);
	glColor3f(0, 1, 0);
	glVertex3f(-669.59,0, 584.023);
	glVertex3f(-669.59,100, 584.023);
	glEnd();

	glBegin(GL_LINES);
	glColor3f(0, 1, 0);
	glVertex3f(-670.41,0, 575.977);
	glVertex3f(-670.41,100, 575.977);
	glEnd();
	*/

	/*
	glBegin(GL_LINES);
	glColor3f(0, 0, 1);
	glVertex3f(-75.8357, 0, 155.539);
	glVertex3f(-75.8357, 100, 155.539);
	glEnd();

	glBegin(GL_LINES);
	glColor3f(0, 0, 1);
	glVertex3f(-771.683, 0, 252.071);
	glVertex3f(-771.683, 100, 252.071);
	glEnd();

	glBegin(GL_LINES);
	glColor3f(0, 0, 1);
	glVertex3f(-774.155, 0, 244.419);
	glVertex3f(-774.155, 100, 244.419);
	glEnd();

	

	glBegin(GL_LINES);
	glColor3f(0, 0, 1);
	glVertex3f(-781.826, 0, 253.562);
	glVertex3f(-781.826, 100, 253.562);
	glEnd();

	glBegin(GL_LINES);
	glColor3f(1, 0, 1);
	glVertex3f(-65.7724, 0, 153.997);
	glVertex3f(-65.7724, 100, 153.997);
	glEnd();
	*/








	glPopMatrix();
}

void Manager::createNew(int carId) {

	//Will be used to obtain a seed for the random number engine
	random_device rd;
	//Standard mersenne_twister_engine seeded with rd()
	mt19937 gen(rd());
	uniform_int_distribution<> distrib(0, mapEntrances.size() - 1);

	int ind = distrib(gen);
	auto it = mapEntrances.begin();
	advance(it, ind);

	auto it2 = waysMap.find(*it);
	if (it2 != waysMap.end()) {

		Car* carObj = new Car(it2->second, carId);
		//Car* carObj = new Car(it2->second.choices[0], car);
		carObj->mapExits = mapExits;
		cars.push_back(carObj);

	}


}

void Manager::resetCar(Car* car) {

	cout << "resetCar inside Manager" << endl;

	//Will be used to obtain a seed for the random number engine
	random_device rd;
	//Standard mersenne_twister_engine seeded with rd()
	mt19937 gen(rd());
	uniform_int_distribution<> distrib(0, mapEntrances.size() - 1);

	int ind = distrib(gen);
	auto it = mapEntrances.begin();
	advance(it, ind);

	auto it2 = waysMap.find(*it);

	if (it2 != waysMap.end()) {
		Parser::WayData wdata = it2->second;

		car->segmentDistances = wdata.distanceSegments[0];
		car->currentDistances = wdata.distanceTables[0];
		car->currentTValues = wdata.tvalue;

		car->firstVector = wdata.choices[0];
		car->currentVector = wdata.choices[0];
		car->totalDists = wdata.totalDistance;
	}
	else {
		cout << "Reset problem" << endl;
	}

	car->reset();
}


void Manager::setupCarLocationVecs() {

	vector<long long> wayIDS = parser.getWayIDS();
	vector<long long> juncsIDS = parser.getJuncIDS();

	for (int i = 0; i < wayIDS.size(); i++) {

		long long wayID = wayIDS[i];

		vector<Car*> newVec;

		carsInWay.emplace(wayID, newVec);

	}


	for (int i = 0; i < juncsIDS.size(); i++) {

		long long juncID = juncsIDS[i];

		vector<Car*> newVec;

		carsInJunc.emplace(juncID, newVec);
	}

}


vector<Car*> Manager::currentCarsAtWay(long long wayID) {
	vector<Car*> currentCars = carsInWay[wayID];

	return currentCars;
}

vector<Car*> Manager::currentCarsAtJunc(long long juncID) {
	vector<Car*> currentCars = carsInWay[juncID];

	return currentCars;
}

void Manager::removeAndAddToVec(int carID, long long oldID, long long newID, int type1, int type2) {

	vector<Car*>::iterator it;
	Car* car;

	// If oldID is from a Way
	if (type1 == 0) {

		// Predicate to capture Car with the same carID as the parameter
		auto pred = [carID](const Car* car) {
			return car->carID == carID;
		};
		// Finding the Car
		it = find_if(begin(carsInWay[oldID]), end(carsInWay[oldID]), pred);

		// Get index of element from iterator
		int index = std::distance(begin(carsInWay[oldID]), it);

		car = carsInWay[oldID][index];

		carsInWay[oldID].erase(carsInWay[oldID].begin() + index);

		// If newID is from a Way
		if (type2 == 0) {
			carsInWay[newID].push_back(car);
		}
		// If newID is from a Junc
		else {
			carsInJunc[newID].push_back(car);
		}
	}
	// If oldID is from a Junc
	else {

		// Predicate to capture Car with the same carID as the parameter
		auto pred = [carID](const Car* car) {
			return car->carID == carID;
		};
		// Finding the Car
		it = find_if(begin(carsInJunc[oldID]), end(carsInJunc[oldID]), pred);

		// Get index of element from iterator
		int index = std::distance(begin(carsInJunc[oldID]), it);

		car = carsInJunc[oldID][index];

		carsInJunc[oldID].erase(carsInJunc[oldID].begin() + index);

		// If newID is from a Way
		if (type2 == 0) {
			carsInWay[newID].push_back(car);
		}
		// If newID is from a Junc
		else {
			carsInJunc[newID].push_back(car);
		}

	}
}


vec3 Manager::getCarInFrontPosition(int carID, long long locationID, int type) {

	vector<Car*>::iterator it;
	Car* car;
	vec3 pos;

	// If locationID is from a Way
	if (type == 0) {

		if (carsInWay[locationID].size() <= 1) {
			cout << "No cars in front " << endl;
			pos = vec3(NULL, NULL, NULL);
		}
		else {


			// Predicate to capture Car with the same carID as the parameter
			auto pred = [carID](const Car* car) {
				return car->carID == carID;
			};
			// Finding the Car
			it = find_if(begin(carsInWay[locationID]), end(carsInWay[locationID]), pred);

			// Get index of element from iterator
			int index = std::distance(begin(carsInWay[locationID]), it);


			// Should this be changed to newPos?
			pos = carsInWay[locationID][index - 1]->position;
		}

	}
	else {
		// TooBad should be treated differently because its a junction?
		if (carsInJunc[locationID].size() <= 1) {
			cout << "No cars in front " << endl;
			pos = vec3(NULL, NULL, NULL);
		}
		else {


			// Predicate to capture Car with the same carID as the parameter
			auto pred = [carID](const Car* car) {
				return car->carID == carID;
			};
			// Finding the Car
			it = find_if(begin(carsInJunc[locationID]), end(carsInJunc[locationID]), pred);

			// Get index of element from iterator
			int index = std::distance(begin(carsInJunc[locationID]), it);

			// Should this be changed to newPos?
			pos = carsInJunc[locationID][index - 1]->position;
		}
	}

	return pos;
}


void Manager::shout() {
	cout << "HELLO MAH FRIEND" << endl;
}


// Orders the roads in an intersection anti-clockwise
// also saves in the intersection struct the intersection points between the roads in pairs(intersect_1, intersect_2)
void Manager::orderRoads() {

	intersections = parser.getAllIntersections();

	int numberInters = intersections->size();

	map<long long, Parser::Intersection>::iterator intersection;

	// REMOVE comment
	//cout << "ALL INTER" << endl;

	int comment = 1;

	for (intersection = intersections->begin(); intersection != intersections->end(); intersection++) {

		vector<vec3> directions;

		long long intPoint = intersection->first;
		if (intPoint == 896610149) {
			comment = 1;
		}

		// REMOVE comment
		//cout << "WHAT" << intPoint << endl;

		//cout << "NEW" << endl;

		// Collect all the direction vectors from the roads in the intersection
		for (auto const& roads : intersection->second.connectedRoads) {
			// REMOVE comment

			/*
			if (comment) {

			cout << "STUFF" << endl;
			cout << roads.size() << endl;


			// REMOVE comment
			for (int i = 0; i < roads.size(); i++) {
				cout << roads[i]->id << endl;
			}

			cout << "ROAAADSSSS" << endl;
			cout << roads[0]->id << endl;

			}
			*/


			vec3 direct;

			if (roads[0]->id == intPoint) {
				vec3 firstNode = vec3(roads[0]->lon, 0, roads[0]->lat);
				vec3 secondNode = vec3(roads[1]->lon, 0, roads[1]->lat);



				direct = secondNode - firstNode;

				/*
				if (comment) {

					cout << "NODES FIRST POINT INTERSECT" << endl;
					cout << "NODE ID" << roads[0]->id << endl;
					cout << "NODE2 ID" << roads[1]->id << endl;
					cout << firstNode.x << "," << firstNode.z << endl;
					cout << secondNode.x << "," << secondNode.z << endl;

					cout << "DIRECTION" << endl;
					cout << direct.x << "," << direct.y << "," << direct.z << endl;
				}
				*/

			}
			else {
				vec3 firstNode = vec3(roads[roads.size() - 1]->lon, 0, roads[roads.size() - 1]->lat);
				vec3 secondNode = vec3(roads[roads.size() - 2]->lon, 0, roads[roads.size() - 2]->lat);


				direct = secondNode - firstNode;

				/*
				if (comment) {

					cout << "NODES LAST POINT INTERSECT" << endl;
					cout << "NODE ID" << roads[roads.size()-1]->id << endl;
					cout << "NODE2 ID" << roads[roads.size()-2]->id << endl;
					cout << firstNode.x << "," << firstNode.y << "," << firstNode.z << endl;
					cout << secondNode.x << "," << secondNode.y << "," << secondNode.z << endl;

					cout << "DIRECTION" << endl;
					cout << direct.x << "," << direct.y << "," << direct.z << endl;
				}
				*/

			}

			directions.push_back(direct);

		}


		vector<pair<float, int>> angles;

		pair<float, int> fixed;
		fixed.first = 0.0;
		fixed.second = 0;

		angles.push_back(fixed);

		vec3 up(0, 1, 0);

		int fixedDir = 0;

		for (int a = 1; a < directions.size(); a++) {

			pair<float, int> auxil;



			float dot = directions[fixedDir].x * directions[a].x + directions[fixedDir].y * directions[a].y + directions[fixedDir].z * directions[a].z;


			float det = directions[fixedDir].x * directions[a].y * up.z + directions[a].x * up.y * directions[fixedDir].z + up.x * directions[fixedDir].y * directions[a].z - directions[fixedDir].z * directions[a].y * up.x - directions[a].z * up.y * directions[fixedDir].x - up.z * directions[fixedDir].y * directions[a].x;

			float angle = atan2(det, dot);

			auxil.first = angle;
			auxil.second = a;

			angles.push_back(auxil);

		}

		sort(angles.begin(), angles.end());


		vector<vector<Parser::Node*>> newOrder;

		for (int i = 0; i < angles.size(); i++) {

			newOrder.push_back(intersection->second.connectedRoads[angles[i].second]);

		}


		cout << "OTHER TEST" << endl;
		cout << "----------------------------" << endl;
		for (int s = 0; s < newOrder.size(); s++) {
			for (int l = 0; l < newOrder[s].size(); l++) {

				cout << newOrder[s][l]->id << endl;
			}
		}



		intersection->second.connectedRoads = newOrder;



		cout << "------------------------------" << endl;

		cout << "TESTING IF CORRECT " << endl;
		for (int i = 0; i < intersection->second.connectedRoads.size(); i++) {

			cout << "ROAD" << endl;
			for (int j = 0; j < intersection->second.connectedRoads[i].size(); j++) {

				cout << intersection->second.connectedRoads[i][j]->id << endl;
			}
		}
		cout << "------------------------------" << endl;



		vector<int> interOrd;


		intersection->second.connectionPoints = findPoints(intersection->second, &interOrd);

		intersection->second.intersectionTypes = interOrd;


		cout << "------------------------------" << endl;

		cout << "TESTING IF CORRECT " << endl;
		for (int i = 0; i < intersection->second.connectedRoads.size(); i++) {


			cout << "ROAD" << endl;
			for (int j = 0; j < intersection->second.connectedRoads[i].size(); j++) {

				cout << intersection->second.connectedRoads[i][j]->id << endl;
			}



			cout << "LEFT POINT " << endl;
			cout << intersection->second.connectionPoints[i].first.x << "," << intersection->second.connectionPoints[i].first.y << "," << intersection->second.connectionPoints[i].first.z << endl;

			cout << "RIGHT POINT " << endl;
			cout << intersection->second.connectionPoints[i].second.x << "," << intersection->second.connectionPoints[i].second.y << "," << intersection->second.connectionPoints[i].second.z << endl;



			cout << "TYPE" << endl;
			cout << intersection->second.intersectionTypes[i] << endl;

		}

	}


	/*

	cout << "~~~~~~~~~~~~~~~~~~" << endl;

	cout << "AMOUNT OF INTERSECTIONS" <<  intersections->size() << endl;
	for (intersection = intersections->begin(); intersection != intersections->end(); intersection++) {

		cout << "NEW ONE" << endl;

		for (int i = 0; i < intersection->second.connectedRoads.size(); i++) {


			cout << "ROAD" << endl;
			for (int j = 0; j < intersection->second.connectedRoads[i].size(); j++) {

				cout << intersection->second.connectedRoads[i][j]->id << endl;
			}



			cout << "LEFT POINT " << endl;
			cout << intersection->second.connectionPoints[i].first.x << "," << intersection->second.connectionPoints[i].first.y << "," << intersection->second.connectionPoints[i].first.z << endl;

			cout << "RIGHT POINT " << endl;
			cout << intersection->second.connectionPoints[i].second.x << "," << intersection->second.connectionPoints[i].second.y << "," << intersection->second.connectionPoints[i].second.z << endl;



			cout << "TYPE" << endl;
			cout << intersection->second.intersectionTypes[i] << endl;

		}


	}

	cout << "~~~~~~~~~~~~~~~~~~" << endl;

	*/

}





vector<pair<vec3, vec3>> Manager::findPoints(Parser::Intersection intersection, vector<int>* interOrd) {

	Path* currPath = new Path();
	vector<Path*> roadPath;

	vector<vector<vec3>> intersectFormation;

	vector<pair<vec3, vec3>> pointResults;

	vector<int> intersectType;

	vec3 intersectP;

	vector<vec3> intersectionPoints;

	vector<pair<int, int>> intersectOrder;

	vector<pair<vector<vec3>, vector<vec3>>> points_aux;
	int comment = 0;

	// REMOVE comment
	//cout << "NEW ORDER" << endl;
	for (int i = 0; i < intersection.connectedRoads.size(); i++) {

		cout << "ROAD" << endl;

		if (intersection.connectedRoads[i][0] == intersection.intersectionPoint) {
			currPath->isIntersection = 1;
		}
		else {
			currPath->isIntersection = 2;
		}

		// Remove comment
		cout << "Current Intersection type " << currPath->isIntersection << endl;


		cout << "OK NEW" << endl;
		for (int a = 0; a < intersection.connectedRoads[i].size(); a++) {
			cout << intersection.connectedRoads[i][a]->id << endl;
		}


		for (int j = 0; j < intersection.connectedRoads[i].size(); j++) {

			cout << "'" << intersection.connectedRoads[i][j]->lon << "," << "0" << "," << intersection.connectedRoads[i][j]->lat << "'" << endl;
			currPath->pushInfo(intersection.connectedRoads[i][j]->id, vec3(intersection.connectedRoads[i][j]->lon, 0.0, intersection.connectedRoads[i][j]->lat));

		}


		currPath->generatePath();
		roadPath.push_back(currPath);
		currPath = new Path();
	}

	vec3(up);
	vector<vec3> pathFormation;
	//int q = 0;


	for (auto const& path : roadPath) {
		//cout << q << endl;
		//q += 1;


		for (int a = 0; a < path->getSegmentNumber(); a++) {



			// TODO problem with points can be over here becaus getPoint(... , float) and I pass it a double
			for (double dt = 0; dt <= 1; dt += 0.1) {


				vec3 newPoint = path->getPoint(a, dt);


				vec3 newDeriv = path->getDerivative(a, dt);

				//TODO possibly normalize deriv before doing the cross product

				vec3 res = cross(newDeriv, up);

				res = normalize(res);


				res.x *= roadHalf;
				res.y = 0;
				res.z *= roadHalf;


				vec3 perpSet1 = newPoint + res;
				vec3 perpSet2 = newPoint - res;


				pathFormation.push_back(perpSet1);
				pathFormation.push_back(perpSet2);

			}

		}


		intersectType.push_back(path->isIntersection);

		// add a vector here (can be local) that saves if the path started with the intersectionPoint or ended
		// after that in line 875 save the important points that are going to be used in the intersection calc
		// use alg in notebook do the necessary comparing and remember to save the points in the following way
		// (left side point, right side point) for each of the roads in the same positions.

		// need to go to the other function with the drawing of the paths and do a similar approach of comparing with 
		// the intersection point and the isIntersection flag. When calculating the pathFormation points don't add 
		// values that are "above" the intersection point (or below if the road starts at the intersection point
		// need to compare 3 times instead of only an if, since it might not be an intersection


		// Used to separate the correct vectors
		intersectFormation.push_back(pathFormation);
		pathFormation.clear();


	}


	pathsTest = intersectFormation;

	// REMOVE comment


	cout << "TEST PATHSETS" << endl;
	for (int s = 0; s < intersectFormation.size(); s++) {

		cout << "FIRST" << endl;
		for (int l = 0; l < intersectFormation[s].size(); l++) {

			cout << intersectFormation[s][l].x << "," << intersectFormation[s][l].y << "," << intersectFormation[s][l].z << endl;
		}
	}

	cout << "TEST PATHSETS 2" << endl;




	for (int s = 0; s < intersectFormation.size(); s++) {

		vector<vec3> points_left;
		vector<vec3> points_right;
		// REMOVE comment
		//cout << "New formation" << endl;

		if (intersectType[s] == 1) {

			//cout << "STARTS WITH" << endl;
			// this should be changed to copy_if or something TODO 
			// Points left
			vec3 point(intersectFormation[s][0].x, 0.0, intersectFormation[s][0].z);
			vec3 point2(intersectFormation[s][4].x, 0.0, intersectFormation[s][4].z);
			points_left.push_back(point);
			points_left.push_back(point2);

			/*
			cout << "POINT 1" << point.x << "," << point.y << "," << point.z << endl;
			cout << "POINT 2" << point2.x << "," << point2.y << "," << point2.z << endl;
			*/


			vec3 point3(intersectFormation[s][1].x, 0.0, intersectFormation[s][1].z);
			vec3 point4(intersectFormation[s][5].x, 0.0, intersectFormation[s][5].z);
			points_right.push_back(point3);
			points_right.push_back(point4);

			/*
			cout << "POINT 3" << point3.x << "," << point3.y << "," << point3.z << endl;
			cout << "POINT 4" << point4.x << "," << point4.y << "," << point4.z << endl;
			*/

		}

		if (intersectType[s] == 2) {
			//cout << "ENDS WITH" << endl;

			vec3 point(intersectFormation[s][intersectFormation[s].size() - 1].x, 0.0, intersectFormation[s][intersectFormation[s].size() - 1].z);
			vec3 point2(intersectFormation[s][intersectFormation[s].size() - 5].x, 0.0, intersectFormation[s][intersectFormation[s].size() - 5].z);

			/*
			cout << "POINT 1 " << point.x << "," << point.y << "," << point.z << endl;
			cout << "POINT 2 " << point2.x << "," << point2.y << "," << point2.z << endl;
			*/


			points_right.push_back(point);
			points_right.push_back(point2);

			vec3 point3(intersectFormation[s][intersectFormation[s].size() - 2].x, 0.0, intersectFormation[s][intersectFormation[s].size() - 2].z);
			vec3 point4(intersectFormation[s][intersectFormation[s].size() - 6].x, 0.0, intersectFormation[s][intersectFormation[s].size() - 6].z);

			/*
			cout << "POINT 3 " << point3.x << "," << point3.y << "," << point3.z << endl;
			cout << "POINT 4 " << point4.x << "," << point4.y << "," << point4.z << endl;
			*/


			points_left.push_back(point3);
			points_left.push_back(point4);

		}
		pair<vector<vec3>, vector<vec3>> both(points_left, points_right);
		points_aux.push_back(both);

	}


	for (int i = 0; i < intersectType.size(); i++) {
		vector<vec3> pointsToUse;
		int compare_next = i + 1;
		int flagRoad1 = 0;
		int flagRoad2 = 0;
		cout << "Intersect Type " << intersectType[i] << endl;


		if (i == intersectType.size() - 1) {
			compare_next = 0;
		}
		cout << "Intersect Type2 " << intersectType[compare_next] << endl;

		if (intersectType[i] == 1) {
			pointsToUse.push_back(points_aux[i].first[0]);
			pointsToUse.push_back(points_aux[i].first[1]);



			flagRoad1 = 1;

			if (intersectType[compare_next] == 1) {
				pointsToUse.push_back(points_aux[compare_next].second[0]);
				pointsToUse.push_back(points_aux[compare_next].second[1]);

				flagRoad2 = 1;
			}
			else {
				pointsToUse.push_back(points_aux[compare_next].first[0]);
				pointsToUse.push_back(points_aux[compare_next].first[1]);

				flagRoad2 = 2;
			}
		}

		if (intersectType[i] == 2) {
			pointsToUse.push_back(points_aux[i].second[0]);
			pointsToUse.push_back(points_aux[i].second[1]);

			/*
			cout << "Intersection Type 2" << endl;
			cout << "Point 1 " << points_aux[i].second[0].x << "," << points_aux[i].second[0].y << "," <<  points_aux[i].second[0].z << endl;
			cout << "Point 2 " << points_aux[i].second[1].x << "," << points_aux[i].second[1].y << "," << points_aux[i].second[1].z << endl;
			*/




			flagRoad1 = 2;

			if (intersectType[compare_next] == 1) {
				/*
				cout << "HERE" << endl;
				cout << points_aux[compare_next].second[0].x << points_aux[compare_next].second[1].z << endl;
				*/

				pointsToUse.push_back(points_aux[compare_next].second[0]);
				pointsToUse.push_back(points_aux[compare_next].second[1]);

				flagRoad2 = 1;
			}
			else {

				pointsToUse.push_back(points_aux[compare_next].first[0]);
				pointsToUse.push_back(points_aux[compare_next].first[1]);

				flagRoad2 = 2;
			}
		}

		IntersectionAux::DoLineSegmentIntersection(pointsToUse[0], pointsToUse[1], pointsToUse[2], pointsToUse[3], &intersectP);

		if (intersectP.x == 0 && intersectP.z == 0) {


			intersectP = pointsToUse[0];
			intersectP.y = 0;
			cout << "INTERSECT P " << endl;
			cout << intersectP.x << "," << intersectP.y << "," << intersectP.z << endl;


			vector<vec3> auxiliarPoints;
			int comparable = 0;

			if (i == 0) {
				comparable = intersectType.size() - 1;
			}
			else {
				comparable = i - 1;
			}



			// In this case we want to compare both of the roads that have no roads that intersect (except horizontally)
			// We get the points on the right and left in this order
			if (intersectType[comparable] == 1) {
				auxiliarPoints.push_back(points_aux[comparable].first[0]);
				auxiliarPoints.push_back(points_aux[comparable].first[1]);

				auxiliarPoints.push_back(points_aux[comparable].second[0]);
				auxiliarPoints.push_back(points_aux[comparable].second[1]);


			}
			else {
				auxiliarPoints.push_back(points_aux[comparable].second[0]);
				auxiliarPoints.push_back(points_aux[comparable].second[1]);

				auxiliarPoints.push_back(points_aux[comparable].first[0]);
				auxiliarPoints.push_back(points_aux[comparable].first[1]);

			}

			pair<int, int> auxil;


			auxil.first = flagRoad1;
			auxil.second = flagRoad2;


			intersectOrder.push_back(auxil);

			// pointsToUse[0], pointsToUse[1]
			// Get the change in x and z between the first and second coordinates
			float dx1 = auxiliarPoints[1].x - auxiliarPoints[0].x;
			float dz1 = auxiliarPoints[1].z - auxiliarPoints[0].z;

			float dx2 = auxiliarPoints[3].x - auxiliarPoints[2].x;
			float dz2 = auxiliarPoints[3].z - auxiliarPoints[2].z;

			// then using the change, extrapolate backwards to find a control point.
			float x1 = auxiliarPoints[0].x - dx1;
			float z1 = auxiliarPoints[0].z - dz1;

			float x3 = auxiliarPoints[2].x - dx2;
			float z3 = auxiliarPoints[2].z - dz2;

			// extrapolate forwards to find a control point
			float x2 = auxiliarPoints[1].x + dx1;
			float z2 = auxiliarPoints[1].z + dz1;

			float x4 = auxiliarPoints[3].x + dx2;
			float z4 = auxiliarPoints[3].z + dz2;

			// create start point from extrapolated values.
			vec3 pointA(x1, 0, z1);

			// create end point from extrapolated values
			vec3 pointB(x2, 0, z2);


			vec3 pointC(x3, 0, z3);
			vec3 pointD(x4, 0, z4);


			IntersectionAux::DoLineSegmentIntersection(pointsToUse[0], pointsToUse[1], pointA, pointB, &intersectP);

			cout << ".........................................." << endl;
			cout << "TESTING INTERSECTION POINT" << endl;
			cout << intersectP.x << "," << intersectP.y << "," << intersectP.z << endl;

			intersectionPoints.push_back(intersectP);

			IntersectionAux::DoLineSegmentIntersection(pointsToUse[2], pointsToUse[3], pointC, pointD, &intersectP);

			cout << ".........................................." << endl;
			cout << "TESTING INTERSECTION POINT" << endl;
			cout << intersectP.x << "," << intersectP.y << "," << intersectP.z << endl;


		}


		// CHECK IF Nume_a and Nume_b are very close to 0 
		// if they are consider them coincident and draw a line from the center into one of the lines and check intersection.
		// if I want then draw a line from that point and a line
		//Add here that if the lines do not intersect (probably check if nume_A and nume_B are close to 0) then use one of the points as a 
		// intersection Point pointsToUse[0] or pointsToUse[2]


		pair<int, int> auxil;

		auxil.first = flagRoad1;
		auxil.second = flagRoad2;



		intersectOrder.push_back(auxil);
		// REMOVE comment
		//cout << " Inter Point" << endl;
		//cout << intersectP.x << "," << intersectP.z << endl;

		intersectionPoints.push_back(intersectP);



	}


	cout << "INTERSECTION POINTS" << endl;
	cout << "------------------------------" << endl;
	for (int i = 0; i < intersectionPoints.size(); i++) {
		cout << intersectionPoints[i].x << "," << intersectionPoints[i].y << "," << intersectionPoints[i].z << endl;
	}
	cout << "--------------------------" << endl;



	for (int i = 0; i < intersectionPoints.size(); i++) {
		pair<vec3, vec3> point;


		if (i == 0) {

			if (intersectOrder[i].first == 1) {
				point.first = intersectionPoints[0];
				point.second = intersectionPoints[intersectionPoints.size() - 1];
			}
			else {
				point.first = intersectionPoints[intersectionPoints.size() - 1];
				point.second = intersectionPoints[0];
			}
		}
		else {
			if (intersectOrder[i].first == 1) {
				point.first = intersectionPoints[i];
				point.second = intersectionPoints[i - 1];
			}
			else {
				point.first = intersectionPoints[i - 1];
				point.second = intersectionPoints[i];
			}
		}

		/*
		if (i == 0) {
			if (intersectOrder[i].first == 1) {
				point.first = intersectionPoints[i];
				point.second = intersectionPoints[intersectionPoints.size() - 1];
			}
			else {
				point.first = intersectionPoints[intersectionPoints.size() - 1];
				point.second = intersectionPoints[i];

			}

		}
		else {
			if (intersectOrder[i].first == 1) {
				point.first = intersectionPoints[i];
				point.second = intersectionPoints[i - 1];
			}
			else {
				point.first = intersectionPoints[i - 1];
				point.second = intersectionPoints[i];
			}
		}
		*/

		pointResults.push_back(point);
	}

	cout << "ORDER" << endl;
	for (int i = 0; i < intersectOrder.size(); i++) {
		cout << intersectOrder[i].first << endl;
		interOrd->push_back(intersectOrder[i].first);
	}

	return pointResults;
}
